"use strict";var Furple;(function(s){function g(h){return s.flatten(h.map(w=>s.liftAll(w,(...d)=>d)))}s.flattenArray=g;function f(h,w){return g(h.map(d=>d.map(w)))}s.mapArray=f;function k(h,w){return s.flatten(h.map(d=>s.select(...d.map(w))))}s.selectArray=k;function m(h,w,d){return s.flatten(h.map(u=>s.liftAll(u,(...a)=>a.reduce(d,w))))}s.foldArray=m;function _(h,w,d){const u=s.constant(w);return s.flatten(h.map(a=>N(a,u,d,0,a.length)))}s.foldAssociative=_;function N(h,w,d,u,a){if(u===a)return w;if(u+1===a)return h[u];{const E=u+a>>>1,l=N(h,w,d,u,E),v=N(h,w,d,E,a);return l.lift(v,d)}}})(Furple||(Furple={}));var Furple;(function(s){const g={kind:0,engine:void 0},f=Symbol();function k(i,e){const n=i.parents;if(n!==void 0)for(let t=n.length-1;t>=0;--t){const r=n[t].deref();if(r!==void 0){if(e(r)===f)return f}else n[t]=n[n.length-1],n.pop()}}function m(i,e){const n=i.parents;for(let t=0;t<n.length;){const r=n[t].deref();if(r!==void 0){if(e(r)===f)return f;++t}else n.splice(t,1)}}function _(i,e){switch(i.kind){case 0:case 17:case 18:return;case 1:return k(i,e);case 2:case 3:case 15:case 16:case 6:case 4:case 5:case 11:case 12:case 13:case 14:{const t=i.parent.deref();return t!==void 0?e(t):void 0}case 7:return e(i.parent1)===f?f:e(i.parent2);case 8:{for(const t of i.parents)if(e(t)===f)return f;return}case 10:return m(i,e);case 9:case 19:{const t=i.parent1.deref(),r=i.parent2?.deref();return t!==void 0&&e(t)===f?f:r!==void 0?e(r):void 0}}const n=i}function N(i,e){switch(i.kind){case 17:case 18:{const n=i.parent.deref();n!==void 0&&e(n);return}case 13:{e(i.cell);return}case 14:{for(const n of i.cells)if(e(n)===f)return;return}}}function h(i,e){_(i,e)!==f&&N(i,e)}function w(i,e){for(const n of i.notifiableChildren)e(n)}function d(i,e){w(i,e);for(const n of i.nonNotifiableChildren)e(n);if(i.rule.kind===15||i.rule.kind===16)for(const n of i.rule.f.values())e(n)}s.DO_NOT_SEND=Symbol();const u=Symbol(),a=Symbol(),E=Object.is;class l{rule;value;name=void 0;depth=0;newValue=u;equalityFunc=E;notifiableChildren=[];nonNotifiableChildren=[];constructor(e,n){this.rule=e,this.value=n,_(e,t=>{t.addNotifiableChild(this)}),this.#n()}named(e){return this.name=e,this}#n(){const e=this.depth;let n=0;return h(this.rule,t=>{t.depth>=n&&(n=t.depth+1)}),this.depth=n,n>e}recomputeDepth(){if(!this.#n())return!1;const e=[this];for(;e.length>0;){const n=e.pop();d(n,t=>{t===this&&M(this),t.#n()&&e.push(t)})}return!0}addNotifiableChild(e){this.notifiableChildren.push(e)}addNonNotifiableDependent(e){this.nonNotifiableChildren.push(e)}removeNotifiableChild(e){const n=this.notifiableChildren,t=n.indexOf(e);t>=0&&n.splice(t,1)}removeNonNotifiableChild(e){if(e.rule.kind===17||e.rule.kind===18)this.rule.f.delete(e.rule.key);else{const n=this.nonNotifiableChildren,t=n.indexOf(e);t>=0&&n.splice(t,1)}}isClosed(){return this.rule.kind===0}close(){if(this.rule.engine?.isBusy())throw new Error("close() cannot be called during an FRP transaction");return p(this),this}tidy(){const e=this.rule;let n=!0;if(_(e,t=>{if(!t.isClosed())return n=!1,f}),n)p(this);else if(e.kind===9){const t=e.parent1.deref(),r=e.parent2.deref();t===void 0||t.isClosed()?this.rule={kind:3,engine:e.engine,parent:e.parent2}:(r===void 0||r.isClosed())&&(this.rule={kind:3,engine:e.engine,parent:e.parent1})}else e.kind===10&&e.parents.length===1&&(this.rule={kind:3,engine:e.engine,parent:e.parents[0]})}listen(e){const n=this.rule.engine;return n!==void 0?new l({kind:2,engine:n,parent:new WeakRef(this),f:e},a):this}observe(e){return e(this.value),this.listen(e)}send(e){C(this).send(this,e)}sendAnd(e,n){const t=C(this);t.run(()=>{t.send(this,e),n()})}connect(e){return q(this,e),this}sample(){const e=this.rule.engine;return e!==void 0?e.sample(this):this.value}setEqualityFunction(e){if(d(this,()=>{throw new Error("Equality function should only be set when the cell is originally created")}),this.equalityFunc!==E)throw new Error("This cell already has an equality function");return this.equalityFunc=e,this}map(e){return y(this,e)}lift(e,n){const t=this,r=e,o=t.rule.engine??r.rule.engine,c=n(t.value,r.value);return o===void 0?S(c):new l({kind:7,engine:o,parent1:t,parent2:r,f:n},c)}hold(e){const n=this.rule.engine;return n===void 0?S(e):new l({kind:3,engine:n,parent:new WeakRef(this)},e)}fold(e,n){return R(this,e,n)}foldS(e,n){return T(this,e,n)[1]}foldBoth(e,n){return T(this,e,n)}filter(e){const n=this.rule.engine,t=this;return n!==void 0?new l({kind:5,engine:n,parent:new WeakRef(t),f:e},a):s.NEVER}gate(e){return this.filter(()=>e.sample())}gateLive(e){return this.snapLive(e,(n,t)=>t?n:s.DO_NOT_SEND)}merge(e,n){const t=this,r=e;if(t.isClosed())return e;if(r.isClosed())return t;const o=C(t);return new l({kind:9,engine:o,parent1:new WeakRef(t),parent2:new WeakRef(r),f:n},a)}orElse(e){return W(this,e)}mergeMutex(e){return this.merge(e,()=>{throw new Error("Mutually exclusive streams fired simultaneously")})}snapshot(e,n){return A(this,e,!1,n)}snapLive(e,n){return A(this,e,!0,n)}as(e){return A(this,e,!1,(n,t)=>t)}asLive(e){return A(this,e,!0,(n,t)=>t)}asConstant(e){return y(this,()=>e)}snapshotAll(e,n){return U(this,e,!1,n)}snapAllLive(e,n){return U(this,e,!0,n)}when(e){const n=this.rule;switch(n.kind){case 0:return this.value!==a?S(this.value===e):s.NEVER;case 15:{const t=this;let r=n.f.get(e);return r===void 0&&(r=new l({kind:17,engine:n.engine,parent:new WeakRef(t),key:e},this.value===e),n.f.set(e,r)),r}case 16:{const t=this;let r=n.f.get(e);return r===void 0&&(r=new l({kind:18,engine:n.engine,parent:new WeakRef(t),key:e},a),n.f.set(e,r)),r}}throw new O("Cannot branch on non-BRANCH node",this)}}const v=[l,Uint8Array,Uint8ClampedArray,Uint16Array,Uint32Array,BigUint64Array,Int8Array,Int16Array,Int32Array,BigInt64Array,Float32Array,Float64Array];function z(i){return v.some(e=>i instanceof e)?i:Object.freeze(i)}class I{#n=[];#t=0;#e=0;enqueue(e){const n=this.#n,t=e.depth;for(;n.length<=t;)n.push([]);n[t].push(e),++this.#t}poll(){const e=this.#n;let n=this.#e;for(;n<e.length;){if(e[n].length>0)return--this.#t,e[n].pop();++this.#e,++n}}rebuild(){const e=this.#n.flat();this.reset();for(const n of e)this.enqueue(n)}reset(){for(const e of this.#n)e.length=0;this.#t=0,this.#e=0}}function B(){return new V}s.engine=B;class V{#n=[];#t=new I;#e=0;#s={kind:1,engine:this,parents:void 0,f:void 0};#r(e,n){if(e.value!==a&&e.equalityFunc(e.value,n))return;const t=e.rule;if(t.kind===1&&e.newValue!==u){const r=t.f;if(r===void 0)throw new O("This sink cannot coalesce simultaneous events",e);e.newValue=r(e.newValue,n);return}e.newValue=n,this.#n.push(e),w(e,r=>this.#t.enqueue(r))}#i(e){const n=e.rule;switch(n.kind){case 0:case 17:case 18:throw new O("This node should not be recomputed",e);case 1:{if(n.parents===void 0)return e.newValue;const t=n.f;let r=u;return k(n,o=>{r===u?r=o.newValue:o.newValue!==u&&(r=t(r,o.newValue))}),r!==u?r:s.DO_NOT_SEND}case 2:case 3:{const t=n.parent.deref();return t===void 0?(p(e),s.DO_NOT_SEND):t.newValue}case 4:{const t=n.parent.deref();return t===void 0?(p(e),s.DO_NOT_SEND):n.f(t.newValue)}case 5:{const t=n.parent.deref();if(t===void 0)return p(e),s.DO_NOT_SEND;const r=t.newValue;return n.f(r)?r:s.DO_NOT_SEND}case 6:{const t=n.parent.deref();return t===void 0?(p(e),s.DO_NOT_SEND):n.f(e.value,t.newValue)}case 7:return n.f(D(n.parent1),D(n.parent2));case 8:{const t=n.parents.map(D);return n.f(...t)}case 9:{const t=n.parent1.deref(),r=n.parent2.deref();return t===void 0?r===void 0?(p(e),s.DO_NOT_SEND):(e.rule={kind:3,engine:n.engine,parent:n.parent2},this.#i(e)):r===void 0?(e.rule={kind:3,engine:n.engine,parent:n.parent1},this.#i(e)):r.newValue===u?t.newValue:t.newValue===u?r.newValue:n.f(t.newValue,r.newValue)}case 10:{let t=s.DO_NOT_SEND;return m(n,r=>{if(r.newValue!==u)return t=r.newValue,f}),t}case 11:{const t=n.parent.deref();return t===void 0?(p(e),s.DO_NOT_SEND):n.f(t.newValue,n.cell.value)}case 12:{const t=n.parent.deref();if(t===void 0)return p(e),s.DO_NOT_SEND;const r=n.cells.map(o=>o.value);return n.f(t.newValue,...r)}case 13:{const t=n.parent.deref();return t===void 0?(p(e),s.DO_NOT_SEND):n.f(t.newValue,D(n.cell))}case 14:{const t=n.parent.deref();if(t===void 0)return p(e),s.DO_NOT_SEND;const r=n.cells.map(D);return n.f(t.newValue,...r)}case 15:{const t=n.parent.deref();if(t===void 0)return p(e),s.DO_NOT_SEND;const r=t.newValue,o=n.f.get(t.value),c=n.f.get(r);return o!==void 0&&this.#r(o,!1),c!==void 0&&this.#r(c,!0),r}case 16:{const t=n.parent.deref();if(t===void 0)return p(e),s.DO_NOT_SEND;const r=t.newValue,o=n.f.get(r);return o!==void 0&&this.#r(o,r),r}case 19:{const t=n.parent1.deref();if(t===void 0)return e.rule=n.parent2!==void 0?{kind:3,engine:n.engine,parent:n.parent2}:{kind:0,engine:void 0},this.#i(e);const r=n.parent2?.deref(),o=D(t);return r!==o&&(r?.removeNotifiableChild(e),o?.addNotifiableChild(e),n.parent2=o!==void 0?new WeakRef(o):void 0,e.recomputeDepth()&&this.#t.rebuild()),o===void 0?void 0:o.newValue!==u?o.newValue:o.value!==a?o.value:s.DO_NOT_SEND}}}send(e,n){const t=e;if(t.isClosed())throw new Error("Cannot send to this sink; it is closed");switch(this.#e){case 0:{this.run(()=>this.#r(t,n));break}case 1:{this.#r(t,n);break}default:throw new Error("send() cannot be called during an FRP transaction")}}run(e){if(this.#e!==0)throw new Error("run() cannot be called during an FRP transaction");try{this.#e=1,e(),this.#e=2;const n=this.#t,t=new Set;for(;;){const r=n.poll();if(r===void 0)break;if(t.has(r))continue;t.add(r),J(r)&&(this.#e=3);const o=this.#i(r);this.#e=2,o!==s.DO_NOT_SEND&&this.#r(r,o)}for(const r of this.#n)r.value!==a&&(r.value=r.newValue);this.#e=4;for(const r of this.#n)r.rule.kind===2&&r.rule.f(r.newValue);this.#e=5}finally{this.#t.reset();for(const n of this.#n)n.newValue=u;this.#n.length=0,this.#e=0}}isBusy(){return this.#e===2||this.#e===3}sample(e){return this.#e===2&&console.error("sample() should not be called here"),e.value}cell(e){return new l(this.#s,e)}sink(e){return new l(e!==void 0?{kind:1,engine:this,parents:[],f:e}:this.#s,a)}}s.Engine=V;function q(i,e){const n=i.rule.engine;if(n===void 0)throw new Error("Cannot connect; sink is already closed");if(n.isBusy())throw new Error("Cannot connect during an FRP transaction");if(i.rule.kind!==1)throw new Error("Cannot connect; sink is already connected");e.value!==a&&n.send(i,e.value);const t=i.rule,r=new WeakRef(e);t.parents===void 0?i.rule={kind:3,engine:n,parent:r}:t.parents.push(r),e.addNotifiableChild(i),i.recomputeDepth()}function y(i,e){const n=i.rule.engine;return n===void 0&&i.value===a?s.NEVER:new l(n===void 0?g:{kind:4,engine:n,parent:new WeakRef(i),f:e},i.value!==a?e(i.value):a)}function R(i,e,n){const t=i,r=t.rule.engine;return new l(r===void 0?g:{kind:6,engine:r,parent:new WeakRef(t),f:n},e)}function T(i,e,n){const t=i,r=t.rule.engine;if(r===void 0)return[S(e),s.NEVER];const o=R(i,e,n),c=new l({kind:3,engine:r,parent:new WeakRef(o)},a);return[o,c]}function A(i,e,n,t){const r=i,o=e,c=r.rule.engine;if(c===void 0)return s.NEVER;const b=n?13:11;return new l({kind:b,engine:c,parent:new WeakRef(r),cell:o,f:t},a)}function U(i,e,n,t){if(e.length===0)return i.map(t);if(e.length===1)return A(i,e[0],n,t);const r=i,o=e,c=r.rule.engine;if(c===void 0)return s.NEVER;const b=n?14:12;return new l({kind:b,engine:c,parent:new WeakRef(r),cells:o,f:t},a)}s.NEVER=new l(g,a);function S(i){return new l(g,i)}s.constant=S,s.UNDEFINED=S(void 0);function P(i,e){const n=i;let t;for(const c of n)if(t=c.rule.engine,t!==void 0)break;if(n.length===0)return S(e());if(n.length===1)return n[0].map(e);if(n.length===2)return n[0].lift(n[1],e);const r=n.map(c=>c.value),o=e(...r);return t===void 0?S(o):new l({kind:8,engine:t,parents:n,f:e},o)}s.liftAll=P;function W(...i){const e=i.filter(t=>!t.isClosed());if(e.length===0)return s.NEVER;if(e.length===1)return e[0];const n=C(e[0]);return new l({kind:10,engine:n,parents:e.map(t=>new WeakRef(t))},a)}s.select=W;function j(i){const e=i,n=e.rule.engine;if(n===void 0)return e;const t=e.value!==a?15:16;return new l({kind:t,engine:n,parent:new WeakRef(e),f:new Map},e.value)}s.branch=j;function x(i){const e=i,n=e.value,t=e.rule.engine;if(t===void 0)return n??s.UNDEFINED;const r={kind:19,engine:t,parent1:new WeakRef(e),parent2:n!==void 0?new WeakRef(n):void 0};return new l(r,n?.value)}s.flatten=x;function L(i,e,n=s.Type.STR){const t=r=>{try{window.localStorage.setItem(i,n.toStr(r))}catch(o){console.error(`Failed to store '${i}' in local storage`,o)}};try{const r=e,o=window.localStorage.getItem(i);o!==null?(r.send(n.fromStr(o)),r.listen(t)):r.observe(t)}catch{console.warn(`Failed to load '${i}' from local storage`)}}s.persist=L;function C(i){const e=i.rule.engine;if(e===void 0)throw new O("Node is closed",i);return e}function D(i){return i.newValue!==u?i.newValue:i.value}function J(i){switch(i.rule.kind){case 4:return i.value===a;case 5:case 6:case 9:case 11:case 12:return!0;default:return!1}}function p(i){if(i.isClosed())return;const e=i.rule;i.rule=g,i.depth=0,_(e,n=>n.removeNotifiableChild(i)),N(e,n=>n.removeNonNotifiableChild(i)),d(i,n=>n.tidy()),i.notifiableChildren.length=0,i.nonNotifiableChildren.length=0}function H(i){if(i.value===a)throw new O("Expected cell",i)}function Q(i,...e){for(const n of e)if(n.rule.engine!==void 0&&n.rule.engine!==i)throw new O("Object is owned by a different FRP engine",[i,n])}function G(...i){if(i.every(e=>e.newValue===u))throw new O("At least one of these nodes should have been updated",i)}function M(i){const e=new Map,n=[i];for(;;){const t=n.shift();if(t===void 0)throw new O("Expected to report cycle, but no cycle was found!",i);h(t.rule,r=>{if(r===i){const o=[];let c=t;for(;c!==void 0;)o.push(c),c=e.get(c);o.reverse();const b=`Circular dependency:
---
`+o.map($=>$.name??"<anonymous>").join(`
`);throw console.error(b,o),new Error(`${b}
---
See console for more details`)}else e.has(r)||(n.push(r),e.set(r,t))})}}class O extends Error{data;constructor(e,n){super(e),this.data=n}}})(Furple||(Furple={}));var Furple;(function(s){let g;(function(f){const k=u=>u,m=u=>`${u}`;f.BOOL={toStr:u=>u?"true":"false",fromStr:u=>u==="true"},f.INT={toStr:m,fromStr:u=>parseInt(u)},f.BIGINT={toStr:m,fromStr:BigInt},f.FLOAT={toStr:m,fromStr:parseFloat},f.STR={toStr:k,fromStr:k};function _(u){return{toStr:a=>JSON.stringify(a.map(u.toStr)),fromStr:a=>JSON.parse(a).map(u.fromStr)}}f.array=_;function N(u){return{toStr:a=>JSON.stringify(d(a,u.toStr)),fromStr:a=>d(JSON.parse(a),u.fromStr)}}f.object=N;function h(u){return{toStr:a=>JSON.stringify(d(Object.fromEntries(a),u.toStr)),fromStr:a=>new Map(Object.entries(d(JSON.parse(a),u.fromStr)))}}f.map=h;function w(u){return{toStr:a=>JSON.stringify([...a].map(u.toStr)),fromStr:a=>new Set(JSON.parse(a).map(u.fromStr))}}f.set=w;function d(u,a){const E=Object.create(null);for(const[l,v]of Object.entries(u))E[l]=a(v);return E}})(g=s.Type||(s.Type={}))})(Furple||(Furple={}));
